/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.navaile.enigma4k;

import com.zackehh.siphash.*;
import java.text.NumberFormat;
import java.util.*;
import org.apache.log4j.*;

/**
 * Crypt based on the Enigma/Fialka/SIGABA, attempts have been made to
 * remove known weaknesses.
 * 
 * Rotor/Plugboard Permutations
 * perm		= factorial(rotorSize)
 *			= 46,655!
 *			= 1.478143766589091023060 x 10^197568
 *			= 10^10^5.295716976537452
 * 
 * Known Limitations
 * Rotor/plugboard variations are limited by 64bit seed.
 * = (64bit permutations) / (rotor/pb permutations)
 * = (9.22 x 10^18 * 2) / (1.478 x 10^197568)
 * = only a tiny percent of all possible permutations is possible due to the
 *		limitations of current computer architecture
 * 
 * random seed size of:
 * 10^197568 = 2^x
 * x = 197568*ln(10)/ln(2)
 * x = 656306.68
 * 2^656306.68 size long seed required for all ro/pb permutations
 * 
 * TODO optimize/refactor
 *
 * @author navaile
 */
public class Crypt {
	
	private static final Logger LOG = Logger.getLogger(Crypt.class);
	
	public static final String VER = "3.4";

	/** Directory size.							*/
	public static final int DIR_SIZE = 46_655;			// ZZZ (base36)

	/** Number of rotors in the enigma machine.	*/
	public static final int COUNT_MIN = 97;
	public static final int COUNT_MAX = 46_655;			// ZZZ (base36)
	private static final int RO_COUNT_MAX = 4_000;
	private static final int PB_COUNT_MAX = 500;		// 500 (2 pages of text)
	
	/**
	 * Hash key, used to generate seeds. Feel free to change, both parties
	 * must have the same hashKey, this will insure same pseudorandom number
	 * generation by Random.
	 */
	private static final String HASH_KEY = "navaile_Enigma4K";
	
	private final Random RND;
	private static final Directory DIRECT = Directory.getInstance();
	
	private final int[][] roMatrix;
	private final int[][] pbMatrix;
	
	/** Rotor Key		*/			private final int[] roKey;
	/** Index for each rotor */		private final int[] roIndex;
	/** Rotor direction spin */		private final int[] roSpin;
	
	/**
	 * Builds Crypto, configures settings.
	 * 
	 * @param passPhrase pass phrase, password
	 * @param handle recipient name/email/handle
	 * @param msgID msgID auto generated by genMsgID()
	 * @param roCount rotor count, 97 - 4000
	 * @param pbCount plugboard count, 97 - 500
	 * @param encrypt encryption flag, true if encrypting
	 */
	public Crypt(String passPhrase, String handle, String msgID, int roCount,
			int pbCount, boolean encrypt) {

		LOG.info("ini Crypt()");
		LOG.info("passPhrase: " + passPhrase + ", handle: " + handle + ", msgID: " + msgID);

		if(msgID == null)	msgID = "";
		passPhrase = String.join(passPhrase, handle, msgID, "!@#$%^&*()");
		RND = new Random(cryptHash(passPhrase));
		
		roCount = setCount(RND, roCount, COUNT_MIN, RO_COUNT_MAX);
		pbCount = setCount(RND, pbCount, COUNT_MIN, PB_COUNT_MAX);

		LOG.info("ini Crypt(" + roCount + ", " + pbCount + ")");
		
		LOG.info("ini Crypt: genKey, copy to rotorIndex");
		roKey = genKey(RND, roCount, DIR_SIZE);
		roIndex = roKey.clone();
		
		roSpin = roSpin(RND, roCount);
		
		LOG.info("ini Crypt: generate random rotors/plugboards");
		
		roMatrix = iniMatrix(RND, roCount, DIR_SIZE, encrypt);
		pbMatrix = iniMatrix(RND, pbCount, DIR_SIZE, encrypt);
		
		memory();
		
		LOG.info("Rotor Count: " + roCount);
		LOG.info("Rotor Key: " + Arrays.toString(roKey));
		LOG.info("Rotor Direction: " + Arrays.toString(roSpin));
		LOG.info("Plugboard Count: " + pbCount);
	}
	
	/**
	 * Verifies rotor and plugboard count is within bounds.
	 * 
	 * @param rnd random number generator
	 * @param count value to check
	 * @param min minimum bounds
	 * @param max max bounds
	 * @return value within bounds \u00B1 10% of original
	 */
	private int setCount(Random rnd, int count, int min, int max) {
		count =  count < min ? min : count > max ? max : count;
		return (int)( (count * .80) + (count * (rnd.nextFloat() * .20)) );
	}
	
	/**
	 * Builds rotor/plugboard matrix.
	 * 
	 * @param rnd random number generator
	 * @param count rotor count or plugboard count
	 * @param DIR_SIZE directory size
	 * @param encrypt encryption flag, true if encrypting
	 * 
	 * @return return matrix
	 */
	private int[][] iniMatrix(Random rnd, int count, int DIR_SIZE, boolean encrypt) {
		
		int[][] matrix = new int[count][];
		for(int i = 0; i < matrix.length; i++) {
			if(encrypt)		matrix[i] = genRotorPb(rnd, DIR_SIZE);
			else			matrix[i] = invArr(genRotorPb(rnd, DIR_SIZE));
		}
		
		return matrix;
	}
	
	/**
	 * Generate message id.
	 * 
	 * @return message id
	 */
	public static String genMsgID() {
		
		final StringBuilder time = new StringBuilder();
		final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
			time.append(cal.get(Calendar.SECOND))
				.append(cal.get(Calendar.MINUTE))
				.append(cal.get(Calendar.HOUR_OF_DAY))
				.append(cal.get(Calendar.DAY_OF_YEAR))
				.append(cal.get(Calendar.YEAR));
			
		long msgID = Long.parseLong(time.toString());

		return padText(longToBase36(msgID).toUpperCase(), 9, "0");
	}
	
	/**
	 * Sets rotor direction spin.
	 * 
	 * @param rnd random number generator
	 * @param roCount rotor count
	 * @return array, each value designates spin direction for that rotor
	 */
	private int[] roSpin(Random rnd, int roCount) {
		
		int[] spin = new int[roKey.length];
		for(int i = 0; i < spin.length; i++)
			spin[i] = (rnd.nextBoolean() ? 1 : -1);
		
		return spin;
	}

	/**
	 * Steps/rotates rotor after each word encryption.
	 * 
	 * @param rnd random number generator
	 * @param rotorIndex rotor index
	 * @param roSpin rotor direction spin array, forward: 1, backward: -1
	 * @param DIR_SIZE directory size
	 */
	private void stepRotors(Random rnd, int[] rotorIndex, int[] roSpin, int DIR_SIZE) {
		
		// TODO implement this
//		if(rnd.nextDouble() > .9955)		roSpin(rnd, roCount);

		for(int i = 0; i < rotorIndex.length; i++) {
			rotorIndex[i] += rnd.nextInt(31) * roSpin[i];
			if(rotorIndex[i] >= DIR_SIZE) rotorIndex[i] = rotorIndex[i] % DIR_SIZE;
			else if(rotorIndex[i] < 0) rotorIndex[i] = DIR_SIZE + rotorIndex[i];
		}
		
		LOG.info("stepRotors() new rotor settings: " + Arrays.toString(rotorIndex));
	}

	/**
	 * Generates a new rotor key.
	 * 
	 * @param rnd random number generator
	 * @param roCount rotor count
	 * @param DIR_SIZE directory size
	 * @return a random key
	 */
	private int[] genKey(Random rnd, int roCount, int DIR_SIZE) {
		
		LOG.info("Crypt.genKey() Generates random rotor key.");
		
		final int[] newKey = new int[roCount];
		for (int i = 0; i < newKey.length; i++)
			newKey[i] = rnd.nextInt(DIR_SIZE);

		return newKey;
	}
	
	/**
	 * Randomize rotor order.
	 * 
	 * @param rnd random number generator
	 * @param roKeySize rotor key size, or rotor count
	 * @return a new rotor order
	 */
	private int[] rndOrder(Random rnd, int roKeySize) {			
	
		final int[] newOrder = new int[roKeySize];
		for(int i = 0; i < newOrder.length; i++)	newOrder[i] = i;
		
		Util.shuffle(rnd, newOrder);
		return newOrder;
	}
	
//	/** 
//	 * Resets rotor key.
//	 * 
//	 * @param roKey current rotor key
//	 * @return return reset rotor index
//	 */
//	private int[] resetKey(int[] roKey) {
//		LOG.info("Crypt.resetKey() key: " + Arrays.toString(roKey));
//		return roKey.clone();
//	}
	
	/**
	 * Static encryption.
	 * 
	 * @param passPhrase pass phrase or password
	 * @param handle recipient email, handle, or name
	 * @param roCount rotor count
	 * @param pbCount plugboard count
	 * @param dirSeed directory randomization seed, default is null
	 * @param plainText text message to encrypt
	 * @return encrypted text
	 */
	public static String encryptText(String passPhrase, String handle,
		int roCount, int pbCount, Long dirSeed, String plainText) {
		
		String msgID = Crypt.genMsgID();
		Crypt enigma = new Crypt(passPhrase, handle, msgID, roCount, pbCount, true);
			enigma.randomizeDirectory(dirSeed);
		
		return msgID + enigma.encryptText(plainText);
	}
	
	/**
	 * Encrypt text.
	 * 
	 * @param plainText plaint text to be encrypted
	 * @return crypt text
	 */
	private String encryptText(String plainText) {
		
		LOG.info("Crypt.encryptText(" + plainText + ")");
		
		StringBuilder debugLog = new StringBuilder();

		final String[] wordList = DIRECT.parceWords(plainText.toLowerCase());
		final List<Integer> wordCodeList = new ArrayList<>(wordList.length);
		
		LOG.debug("Crypt.encryptText().wordList.length: " + wordList.length);
		LOG.debug("Crypt.encryptText().wordList.data: " + Arrays.toString(wordList));
		
		for(String word: wordList) {

			final Integer wordCode = DIRECT.getKeyCode(word);
			debugLog.append(word).append(": ").append(wordCode).append(", ");
			
			if(wordCode == null) {

				LOG.debug("Crypt.encryptText letter: " + Arrays.toString(word.toCharArray()));
				
				wordCodeList.add(DIRECT.getKeyCode("<%"));
				for(char l: word.toCharArray()) {
					final Integer keyCode = DIRECT.getKeyCode(String.valueOf(l));
					if(keyCode != null)		wordCodeList.add(keyCode);
				}
				wordCodeList.add(DIRECT.getKeyCode("%>"));
			}
			else {		wordCodeList.add(wordCode);						}
		}
		
		LOG.debug(debugLog.toString());
		
		LOG.debug("Crypt.encryptText.wordCodeList: " + wordCodeList.size());
		LOG.debug("Crypt.encryptText.wordCodeList.data: " + Arrays.toString(wordCodeList.toArray()));
		
		// wordCodeList check
		LOG.debug("wordCodeList: " + Arrays.toString(wordCodeList.toArray()));
		
		final StringBuilder strBuild = new StringBuilder();

		for(int wordCode: wordCodeList) {
			
			debugLog = new StringBuilder();
			debugLog.append("wordCode:").append(wordCode).append(", ");

			int index = RND.nextInt(pbMatrix.length);
			wordCode = pbCrypt(wordCode, index, pbMatrix);
				debugLog.append("pbE:").append(wordCode).append(", ");
			wordCode = roCrypt(RND, roMatrix, roIndex, wordCode, true, DIR_SIZE);
				debugLog.append("rE:").append(wordCode).append(", ");
			stepRotors(RND, roIndex, roSpin, DIR_SIZE);
			wordCode = pbCrypt(wordCode, index, pbMatrix);
				debugLog.append("pbE:").append(wordCode).append(", ");

			String base36Str = padText(intToBase36(wordCode), 3, "0").toUpperCase();
				strBuild.append(base36Str);
				debugLog.append("base36:").append(base36Str);
			
			LOG.debug(debugLog.toString());
		}
		
		LOG.info("Encrypts plain text using the plugboard, then using the rotors.");
				
		return strBuild.toString();
	}
	
	/**
	 * Plugboard encryption/decryption.
	 * 
	 * @param wordCode directory wordCode
	 * @param pbIndex word index of plain text
	 * @param pbMatrix plugboard matrix
	 * @return crypt word
	 */
	private int pbCrypt(int wordCode, int pbIndex, int[][] pbMatrix) {
		
		/* plugboard substitution
		 * each word is substituted using a different plugboard		*/
		final int[] plugboard = pbMatrix[pbIndex];

		LOG.debug("Crypt.pbCrypt(" + wordCode + ", " + pbIndex + "): pbIndex: " +
			(pbIndex % pbMatrix.length) + ", newWordCode: " + plugboard[wordCode]);
		
		return plugboard[wordCode];
	}
	
	/**
	 * Rotor encrypt/decrypt.
	 * 
	 * @param rnd random number generator
	 * @param roMatrix rotor matrix
	 * @param roIndex rotor index
	 * @param wordCode word code integer
	 * @param encrypt encryption flag, true if encrypting
	 * @param DIR_SIZE directory size
	 * @return encrypted/decrypted wordCode
	 */
	private int roCrypt(Random rnd, int[][] roMatrix, int[] roIndex, int wordCode,
			boolean encrypt, int DIR_SIZE) {
		
		LOG.info("Crypt.roCrypt(" + wordCode + ") START");
		
		final int[] roOrder = rndOrder(rnd, roMatrix.length);
		int roID = encrypt ? 0 : roMatrix.length - 1;

		do {
				
			int[] rotor = roMatrix[roOrder[roID]];
			wordCode = encrypt ?
				rotor[((roIndex[roID] + wordCode) % DIR_SIZE)] :
				((((rotor[wordCode] - roIndex[roID]) % DIR_SIZE) + DIR_SIZE) % DIR_SIZE);

			roID += encrypt ? 1 : -1;
		}
		while( (encrypt && roID < roMatrix.length) || (!encrypt && roID >= 0) );

		LOG.info("Crypt.roCrypt() STOP");
		return wordCode;
	}
	
	/**
	 * Static decryption.
	 * 
	 * @param passPhrase pass phrase or password
	 * @param handle recipient email, handle, or name
	 * @param roCount rotor count
	 * @param pbCount plugboard count
	 * @param dirSeed directory randomization seed, default is null
	 * @param cryptText text message to encrypt
	 * @return plain text
	 */
	public static String decryptText(String passPhrase, String handle,
		int roCount, int pbCount, Long dirSeed, String cryptText) {
		
		LOG.info("Crypt.decryptText()");
		
		if(cryptText.length() < 12 || cryptText.length() % 3 != 0 || cryptText.contains(" "))
			return cryptText;
		
		final String msgID = cryptText.substring(0, 9);
		cryptText = cryptText.substring(9, cryptText.length());
						
		Crypt enigma = new Crypt(passPhrase, handle, msgID, roCount, pbCount, false);
			enigma.randomizeDirectory(dirSeed);
		
		return enigma.decryptText(cryptText);
	}
	
	/**
	 * Decrypt crypt text.
	 * 
	 * @param cryptText
	 * @return plaint text
	 */
	private String decryptText(String cryptText) {
		
		LOG.info("Crypt.decryptText()");
		
		if(cryptText.length() % 3 != 0)		return cryptText;
		
		StringBuilder log;

		final String[] cryptTextArr = cryptText.split("(?<=\\G.{3})");
		final StringBuilder text = new StringBuilder();
		boolean wSpace = true;			// white space

		for(String wordCodeStr: cryptTextArr) {
			
			log = new StringBuilder();
			
				log.append("cryptText: ").append(wordCodeStr).append(", ");
			int wordCode = base36ToInt(wordCodeStr);
				log.append("base36ToInt: ").append(wordCode).append(", ");

			int index = RND.nextInt(pbMatrix.length);
			wordCode = pbCrypt(wordCode, index, pbMatrix);
				log.append("pbD:").append(wordCode).append(", ");
			wordCode = roCrypt(RND, roMatrix, roIndex, wordCode, false, DIR_SIZE);
				log.append("rD:").append(wordCode).append(", ");
			stepRotors(RND, roIndex, roSpin, DIR_SIZE);
			wordCode = pbCrypt(wordCode, index, pbMatrix);
				log.append("pbD:").append(wordCode).append(", ");

			String word = DIRECT.getWord(wordCode);
				word = word.replace("\\s,", ",");
				word = word.replace("\\s.", ".");
				log.append("direcWord: ").append(word);

			if(word.equals("<%"))	wSpace = false;
			if(word.equals("%>"))	wSpace = true;

			text.append(word.replace("<%", "").replace("%>", ""));
			if(wSpace)	text.append(" ");

			LOG.debug(log.toString());
		}

		LOG.info("Decrypt encrypted text.");
		
		return text.toString()
			.trim()
			.toUpperCase()
			.replaceAll("\\s{2,}", " ")			// replace multiple spaces
			.replaceAll(" :", ":")				// remove spaces before colon
			.replaceAll(" ;", ";")				// remove spaces before semicolon
			.replaceAll(" ,", ",")				// remove spaces before commas
			.replaceAll(" \\.", ".")			// remove spaces before period
			.replaceAll("\\(\\s", "(")			// remove spaces after parentheses
			.replaceAll("\\s\\)", ")");			// remove space before parentheses
	}
	
	/**
	 * Base 10 to Base 36 conversion.
	 * 
	 * @param base10 base 10 integer
	 * @return base 36 string
	 */
	private static String intToBase36(int base10) {
		return Integer.toString(base10, Character.MAX_RADIX);
	}
	
	/**
	 * Base 36 to Base 10 conversion.
	 * 
	 * @param base36 base 36 string
	 * 
	 * @return base 10 integer
	 */
	private static int base36ToInt(String base36) {
		return Integer.parseInt(base36, Character.MAX_RADIX);
	}
	
	/**
	 * Base 10 to Base 36 conversion.
	 * 
	 * @param base10 long
	 * @return base 36 string
	 */
	private static String longToBase36(long base10) {
		return Long.toString(base10, Character.MAX_RADIX);
	}

	/**
	 * Text to pad.
	 * 
	 * @param str string to pad
	 * @param minSize min string size
	 * @param pad string to use as padding
	 * @return padded string
	 */
	private static String padText(String str, int minSize, String pad) {

		if((minSize - str.length()) > 0)		return padText(pad + str, minSize, pad);
		return str;
	}
	
	/** 
	 * String to long hash using SipHash 64bit.
	 * @param passPhrase used to generate a seed
	 * @return generated seed
	 */
	private static long cryptHash(String passPhrase) {

		// java long hashCode
//		long hash = 0;
//		
//		if(str.length() > 0) {
//			char val[] = str.toCharArray();
//			for(int i = 0; i < str.length(); i++)
//				hash = 31 * hash + val[i];
//		}
//
//		return hash;

		SipHash hasher = new SipHash(HASH_KEY.getBytes());
		return hasher.hash(passPhrase.getBytes()).get();
	}
	
	/**
	 * Builds a random rotor or plugboard.
	 * 
	 * @param rnd random number generator
	 * @param DIR_SIZE directory size
	 * @return a new rotor
	 */
	private static int[] genRotorPb(Random rnd, int DIR_SIZE) {

		int[] arr = new int[DIR_SIZE];			// 46655, ZZZ
		for(int i = 0; i < arr.length; i++)		arr[i] = i;
		
		Util.shuffle(rnd, arr);
		return arr;
	}
	
	/**
	 * Array inversion, index and value switch.
	 * 
	 * @param arr array to invert
	 * @return inverted array
	 */
	private static int[] invArr(int[] arr) {
		
		int[] invArr = new int[arr.length];
		
		for(int index = 0; index < arr.length; index++) {
			int val = arr[index];
			invArr[val] = index;
		}
		
		return invArr;
	}
	
	/**
	 * This method will randomize the directory based on the seed supplied.
	 * Randomizing the directory increases security however both parties must
	 * use the same seed when randomizing the directory to ensure that both
	 * parties have the same directory.
	 * 
	 * @param seed random directory seed
	 */
	public void randomizeDirectory(Long seed) {
		if(DIRECT != null)	DIRECT.randomizeDirectory(seed);
	}
	
	/** 
	 * Memory usage.
	 */
	private static void memory() {
		
		long MEGABYTE = 1024L * 1024L;

		Runtime runtime = Runtime.getRuntime();
		NumberFormat format = NumberFormat.getInstance();

		StringBuilder sb = new StringBuilder();
		long maxMemory = runtime.maxMemory();
		long allocatedMemory = runtime.totalMemory();
		long freeMemory = runtime.freeMemory();

		sb.append("free memory: ").append(format.format(freeMemory / MEGABYTE)).append("\n");
		sb.append("allocated memory: ").append(format.format(allocatedMemory / MEGABYTE)).append("\n");
		sb.append("max memory: ").append(format.format(maxMemory / MEGABYTE)).append("\n");
		sb.append("total free memory: ").append(format.format((freeMemory + (maxMemory - allocatedMemory)) / MEGABYTE)).append("\n");
		
		LOG.debug(sb.toString());
	}
}

